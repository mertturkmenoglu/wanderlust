// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: lists.sql

package db

import (
	"context"
)

const countAllListsOfUser = `-- name: CountAllListsOfUser :one
SELECT COUNT(*) FROM lists
WHERE user_id = $1
`

func (q *Queries) CountAllListsOfUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countAllListsOfUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublicListsOfUser = `-- name: CountPublicListsOfUser :one
SELECT COUNT(*) FROM lists
WHERE user_id = $1 AND is_public = true
`

func (q *Queries) CountPublicListsOfUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countPublicListsOfUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createList = `-- name: CreateList :one
INSERT INTO lists (
  id,
  name,
  user_id,
  is_public
) VALUES (
  $1,
  $2,
  $3,
  $4
) RETURNING id, name, user_id, is_public, created_at, updated_at
`

type CreateListParams struct {
	ID       string
	Name     string
	UserID   string
	IsPublic bool
}

func (q *Queries) CreateList(ctx context.Context, arg CreateListParams) (List, error) {
	row := q.db.QueryRow(ctx, createList,
		arg.ID,
		arg.Name,
		arg.UserID,
		arg.IsPublic,
	)
	var i List
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createListItem = `-- name: CreateListItem :one
INSERT INTO list_items (
  list_id,
  poi_id,
  list_index
) VALUES (
  $1,
  $2,
  $3
) RETURNING list_id, poi_id, list_index, created_at
`

type CreateListItemParams struct {
	ListID    string
	PoiID     string
	ListIndex int32
}

func (q *Queries) CreateListItem(ctx context.Context, arg CreateListItemParams) (ListItem, error) {
	row := q.db.QueryRow(ctx, createListItem, arg.ListID, arg.PoiID, arg.ListIndex)
	var i ListItem
	err := row.Scan(
		&i.ListID,
		&i.PoiID,
		&i.ListIndex,
		&i.CreatedAt,
	)
	return i, err
}

const decrListItemsListIndexAfterDelete = `-- name: DecrListItemsListIndexAfterDelete :exec
UPDATE list_items
SET
  list_index = list_index - 1
WHERE list_id = $1 AND list_index > $2
`

type DecrListItemsListIndexAfterDeleteParams struct {
	ListID    string
	ListIndex int32
}

func (q *Queries) DecrListItemsListIndexAfterDelete(ctx context.Context, arg DecrListItemsListIndexAfterDeleteParams) error {
	_, err := q.db.Exec(ctx, decrListItemsListIndexAfterDelete, arg.ListID, arg.ListIndex)
	return err
}

const deleteAllListItems = `-- name: DeleteAllListItems :exec
DELETE FROM list_items
WHERE list_id = $1
`

func (q *Queries) DeleteAllListItems(ctx context.Context, listID string) error {
	_, err := q.db.Exec(ctx, deleteAllListItems, listID)
	return err
}

const deleteList = `-- name: DeleteList :exec
DELETE FROM lists
WHERE id = $1
`

func (q *Queries) DeleteList(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteList, id)
	return err
}

const deleteListsListItemAtIndex = `-- name: DeleteListsListItemAtIndex :exec
DELETE FROM list_items
WHERE list_id = $1 AND list_index = $2
`

type DeleteListsListItemAtIndexParams struct {
	ListID    string
	ListIndex int32
}

func (q *Queries) DeleteListsListItemAtIndex(ctx context.Context, arg DeleteListsListItemAtIndexParams) error {
	_, err := q.db.Exec(ctx, deleteListsListItemAtIndex, arg.ListID, arg.ListIndex)
	return err
}

const getAllListsOfUser = `-- name: GetAllListsOfUser :many
SELECT id, name, user_id, is_public, created_at, updated_at FROM lists
WHERE user_id = $1
ORDER BY created_at DESC
OFFSET $2
LIMIT $3
`

type GetAllListsOfUserParams struct {
	UserID string
	Offset int32
	Limit  int32
}

func (q *Queries) GetAllListsOfUser(ctx context.Context, arg GetAllListsOfUserParams) ([]List, error) {
	rows, err := q.db.Query(ctx, getAllListsOfUser, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []List
	for rows.Next() {
		var i List
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastIndexOfList = `-- name: GetLastIndexOfList :one
SELECT COALESCE(MAX(list_index), 0)
FROM list_items
WHERE list_id = $1
`

func (q *Queries) GetLastIndexOfList(ctx context.Context, listID string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getLastIndexOfList, listID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const getListById = `-- name: GetListById :one
SELECT 
  lists.id, lists.name, lists.user_id, lists.is_public, lists.created_at, lists.updated_at, 
  users.id, users.email, users.username, users.full_name, users.password_hash, users.google_id, users.fb_id, users.is_email_verified, users.is_onboarding_completed, users.is_active, users.is_business_account, users.is_verified, users.role, users.password_reset_token, users.password_reset_expires, users.login_attempts, users.lockout_until, users.bio, users.pronouns, users.website, users.phone, users.profile_image, users.banner_image, users.followers_count, users.following_count, users.last_login, users.created_at, users.updated_at
FROM lists
  LEFT JOIN users ON users.id = lists.user_id
WHERE lists.id = $1 LIMIT 1
`

type GetListByIdRow struct {
	List List
	User User
}

func (q *Queries) GetListById(ctx context.Context, id string) (GetListByIdRow, error) {
	row := q.db.QueryRow(ctx, getListById, id)
	var i GetListByIdRow
	err := row.Scan(
		&i.List.ID,
		&i.List.Name,
		&i.List.UserID,
		&i.List.IsPublic,
		&i.List.CreatedAt,
		&i.List.UpdatedAt,
		&i.User.ID,
		&i.User.Email,
		&i.User.Username,
		&i.User.FullName,
		&i.User.PasswordHash,
		&i.User.GoogleID,
		&i.User.FbID,
		&i.User.IsEmailVerified,
		&i.User.IsOnboardingCompleted,
		&i.User.IsActive,
		&i.User.IsBusinessAccount,
		&i.User.IsVerified,
		&i.User.Role,
		&i.User.PasswordResetToken,
		&i.User.PasswordResetExpires,
		&i.User.LoginAttempts,
		&i.User.LockoutUntil,
		&i.User.Bio,
		&i.User.Pronouns,
		&i.User.Website,
		&i.User.Phone,
		&i.User.ProfileImage,
		&i.User.BannerImage,
		&i.User.FollowersCount,
		&i.User.FollowingCount,
		&i.User.LastLogin,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
	)
	return i, err
}

const getListIdsAndNamesOfUser = `-- name: GetListIdsAndNamesOfUser :many
SELECT id, name FROM lists
WHERE user_id = $1
`

type GetListIdsAndNamesOfUserRow struct {
	ID   string
	Name string
}

func (q *Queries) GetListIdsAndNamesOfUser(ctx context.Context, userID string) ([]GetListIdsAndNamesOfUserRow, error) {
	rows, err := q.db.Query(ctx, getListIdsAndNamesOfUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListIdsAndNamesOfUserRow
	for rows.Next() {
		var i GetListIdsAndNamesOfUserRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListItem = `-- name: GetListItem :one
SELECT list_id, poi_id, list_index, created_at FROM list_items
WHERE list_id = $1 AND poi_id = $2
LIMIT 1
`

type GetListItemParams struct {
	ListID string
	PoiID  string
}

func (q *Queries) GetListItem(ctx context.Context, arg GetListItemParams) (ListItem, error) {
	row := q.db.QueryRow(ctx, getListItem, arg.ListID, arg.PoiID)
	var i ListItem
	err := row.Scan(
		&i.ListID,
		&i.PoiID,
		&i.ListIndex,
		&i.CreatedAt,
	)
	return i, err
}

const getListItems = `-- name: GetListItems :many
SELECT
  list_items.list_id, list_items.poi_id, list_items.list_index, list_items.created_at,
  pois.id, pois.name, pois.phone, pois.description, pois.address_id, pois.website, pois.price_level, pois.accessibility_level, pois.total_votes, pois.total_points, pois.total_favorites, pois.category_id, pois.open_times, pois.created_at, pois.updated_at,
  categories.id, categories.name, categories.image,
  addresses.id, addresses.city_id, addresses.line1, addresses.line2, addresses.postal_code, addresses.lat, addresses.lng,
  cities.id, cities.name, cities.state_code, cities.state_name, cities.country_code, cities.country_name, cities.image_url, cities.latitude, cities.longitude, cities.description, cities.img_license, cities.img_license_link, cities.img_attr, cities.img_attr_link,
  media.id, media.poi_id, media.url, media.alt, media.caption, media.media_order, media.created_at
  FROM list_items
INNER JOIN pois ON list_items.poi_id = pois.id
LEFT JOIN categories ON pois.category_id = categories.id
LEFT JOIN addresses ON pois.address_id = addresses.id
LEFT JOIN cities ON addresses.city_id = cities.id
LEFT JOIN media ON pois.id = media.poi_id
WHERE media.media_order = 1 AND list_items.list_id = $1
ORDER BY list_items.list_index ASC
`

type GetListItemsRow struct {
	ListItem ListItem
	Poi      Poi
	Category Category
	Address  Address
	City     City
	Medium   Medium
}

func (q *Queries) GetListItems(ctx context.Context, listID string) ([]GetListItemsRow, error) {
	rows, err := q.db.Query(ctx, getListItems, listID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListItemsRow
	for rows.Next() {
		var i GetListItemsRow
		if err := rows.Scan(
			&i.ListItem.ListID,
			&i.ListItem.PoiID,
			&i.ListItem.ListIndex,
			&i.ListItem.CreatedAt,
			&i.Poi.ID,
			&i.Poi.Name,
			&i.Poi.Phone,
			&i.Poi.Description,
			&i.Poi.AddressID,
			&i.Poi.Website,
			&i.Poi.PriceLevel,
			&i.Poi.AccessibilityLevel,
			&i.Poi.TotalVotes,
			&i.Poi.TotalPoints,
			&i.Poi.TotalFavorites,
			&i.Poi.CategoryID,
			&i.Poi.OpenTimes,
			&i.Poi.CreatedAt,
			&i.Poi.UpdatedAt,
			&i.Category.ID,
			&i.Category.Name,
			&i.Category.Image,
			&i.Address.ID,
			&i.Address.CityID,
			&i.Address.Line1,
			&i.Address.Line2,
			&i.Address.PostalCode,
			&i.Address.Lat,
			&i.Address.Lng,
			&i.City.ID,
			&i.City.Name,
			&i.City.StateCode,
			&i.City.StateName,
			&i.City.CountryCode,
			&i.City.CountryName,
			&i.City.ImageUrl,
			&i.City.Latitude,
			&i.City.Longitude,
			&i.City.Description,
			&i.City.ImgLicense,
			&i.City.ImgLicenseLink,
			&i.City.ImgAttr,
			&i.City.ImgAttrLink,
			&i.Medium.ID,
			&i.Medium.PoiID,
			&i.Medium.Url,
			&i.Medium.Alt,
			&i.Medium.Caption,
			&i.Medium.MediaOrder,
			&i.Medium.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListItemsInListStatus = `-- name: GetListItemsInListStatus :many
SELECT list_id, poi_id FROM list_items
WHERE list_items.poi_id = $1 AND list_items.list_id = ANY($2::TEXT[])
`

type GetListItemsInListStatusParams struct {
	PoiID   string
	Column2 []string
}

type GetListItemsInListStatusRow struct {
	ListID string
	PoiID  string
}

func (q *Queries) GetListItemsInListStatus(ctx context.Context, arg GetListItemsInListStatusParams) ([]GetListItemsInListStatusRow, error) {
	rows, err := q.db.Query(ctx, getListItemsInListStatus, arg.PoiID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListItemsInListStatusRow
	for rows.Next() {
		var i GetListItemsInListStatusRow
		if err := rows.Scan(&i.ListID, &i.PoiID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicListsOfUser = `-- name: GetPublicListsOfUser :many
SELECT id, name, user_id, is_public, created_at, updated_at FROM lists
WHERE user_id = $1 AND is_public = true
ORDER BY created_at DESC
OFFSET $2
LIMIT $3
`

type GetPublicListsOfUserParams struct {
	UserID string
	Offset int32
	Limit  int32
}

func (q *Queries) GetPublicListsOfUser(ctx context.Context, arg GetPublicListsOfUserParams) ([]List, error) {
	rows, err := q.db.Query(ctx, getPublicListsOfUser, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []List
	for rows.Next() {
		var i List
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateList = `-- name: UpdateList :exec
UPDATE lists
SET 
  name = $2,
  is_public = $3
WHERE id = $1
`

type UpdateListParams struct {
	ID       string
	Name     string
	IsPublic bool
}

func (q *Queries) UpdateList(ctx context.Context, arg UpdateListParams) error {
	_, err := q.db.Exec(ctx, updateList, arg.ID, arg.Name, arg.IsPublic)
	return err
}
