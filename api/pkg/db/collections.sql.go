// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: collections.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
)

type BatchCreateCollectionCityRelationsParams struct {
	CollectionID string
	CityID       int32
	Index        int32
}

type BatchCreateCollectionItemsParams struct {
	CollectionID string
	PlaceID      string
	Index        int32
}

type BatchCreateCollectionPlaceRelationsParams struct {
	CollectionID string
	PlaceID      string
	Index        int32
}

type BatchCreateCollectionsParams struct {
	ID          string
	Name        string
	Description string
}

const countCollections = `-- name: CountCollections :one
SELECT COUNT(*) FROM collections
`

func (q *Queries) CountCollections(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCollections)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (
  id,
  name,
  description
) VALUES (
  $1,
  $2,
  $3
) RETURNING id, name, description, created_at
`

type CreateCollectionParams struct {
	ID          string
	Name        string
	Description string
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, createCollection, arg.ID, arg.Name, arg.Description)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createCollectionCityRelation = `-- name: CreateCollectionCityRelation :one
INSERT INTO collections_cities (
  collection_id,
  city_id,
  index
) VALUES (
  $1,
  $2,
  $3
) RETURNING collection_id, city_id, index
`

type CreateCollectionCityRelationParams struct {
	CollectionID string
	CityID       int32
	Index        int32
}

func (q *Queries) CreateCollectionCityRelation(ctx context.Context, arg CreateCollectionCityRelationParams) (CollectionsCity, error) {
	row := q.db.QueryRow(ctx, createCollectionCityRelation, arg.CollectionID, arg.CityID, arg.Index)
	var i CollectionsCity
	err := row.Scan(&i.CollectionID, &i.CityID, &i.Index)
	return i, err
}

const createCollectionItem = `-- name: CreateCollectionItem :one
INSERT INTO collection_items (
  collection_id,
  place_id,
  index
) VALUES (
  $1,
  $2,
  $3
) RETURNING collection_id, place_id, index, created_at
`

type CreateCollectionItemParams struct {
	CollectionID string
	PlaceID      string
	Index        int32
}

func (q *Queries) CreateCollectionItem(ctx context.Context, arg CreateCollectionItemParams) (CollectionItem, error) {
	row := q.db.QueryRow(ctx, createCollectionItem, arg.CollectionID, arg.PlaceID, arg.Index)
	var i CollectionItem
	err := row.Scan(
		&i.CollectionID,
		&i.PlaceID,
		&i.Index,
		&i.CreatedAt,
	)
	return i, err
}

const createCollectionPlaceRelation = `-- name: CreateCollectionPlaceRelation :one
INSERT INTO collections_places (
  collection_id,
  place_id,
  index
) VALUES (
  $1,
  $2,
  $3
) RETURNING collection_id, place_id, index
`

type CreateCollectionPlaceRelationParams struct {
	CollectionID string
	PlaceID      string
	Index        int32
}

func (q *Queries) CreateCollectionPlaceRelation(ctx context.Context, arg CreateCollectionPlaceRelationParams) (CollectionsPlace, error) {
	row := q.db.QueryRow(ctx, createCollectionPlaceRelation, arg.CollectionID, arg.PlaceID, arg.Index)
	var i CollectionsPlace
	err := row.Scan(&i.CollectionID, &i.PlaceID, &i.Index)
	return i, err
}

const decrementCollectionIndexAfterDelete = `-- name: DecrementCollectionIndexAfterDelete :execresult
UPDATE collection_items
SET
  index = index - 1
WHERE collection_id = $1 AND index > $2
`

type DecrementCollectionIndexAfterDeleteParams struct {
	CollectionID string
	Index        int32
}

func (q *Queries) DecrementCollectionIndexAfterDelete(ctx context.Context, arg DecrementCollectionIndexAfterDeleteParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, decrementCollectionIndexAfterDelete, arg.CollectionID, arg.Index)
}

const findCollectionItemByCollectionIdAndPlaceId = `-- name: FindCollectionItemByCollectionIdAndPlaceId :one
SELECT collection_id, place_id, index, created_at FROM collection_items
WHERE collection_id = $1 AND place_id = $2
LIMIT 1
`

type FindCollectionItemByCollectionIdAndPlaceIdParams struct {
	CollectionID string
	PlaceID      string
}

func (q *Queries) FindCollectionItemByCollectionIdAndPlaceId(ctx context.Context, arg FindCollectionItemByCollectionIdAndPlaceIdParams) (CollectionItem, error) {
	row := q.db.QueryRow(ctx, findCollectionItemByCollectionIdAndPlaceId, arg.CollectionID, arg.PlaceID)
	var i CollectionItem
	err := row.Scan(
		&i.CollectionID,
		&i.PlaceID,
		&i.Index,
		&i.CreatedAt,
	)
	return i, err
}

const findCollectionLastIndexById = `-- name: FindCollectionLastIndexById :one
SELECT
  COALESCE(MAX(index), 0)
FROM collection_items
WHERE collection_id = $1
`

func (q *Queries) FindCollectionLastIndexById(ctx context.Context, collectionID string) (interface{}, error) {
	row := q.db.QueryRow(ctx, findCollectionLastIndexById, collectionID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const findManyCollectionCityRelations = `-- name: FindManyCollectionCityRelations :many
SELECT collection_id, city_id, index FROM collections_cities
`

func (q *Queries) FindManyCollectionCityRelations(ctx context.Context) ([]CollectionsCity, error) {
	rows, err := q.db.Query(ctx, findManyCollectionCityRelations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CollectionsCity
	for rows.Next() {
		var i CollectionsCity
		if err := rows.Scan(&i.CollectionID, &i.CityID, &i.Index); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findManyCollectionIds = `-- name: FindManyCollectionIds :many
SELECT id FROM collections
ORDER BY created_at DESC
OFFSET $1
LIMIT $2
`

type FindManyCollectionIdsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) FindManyCollectionIds(ctx context.Context, arg FindManyCollectionIdsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, findManyCollectionIds, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findManyCollectionIdsByCityId = `-- name: FindManyCollectionIdsByCityId :many
SELECT collection_id FROM collections_cities
WHERE city_id = $1
`

func (q *Queries) FindManyCollectionIdsByCityId(ctx context.Context, cityID int32) ([]string, error) {
	rows, err := q.db.Query(ctx, findManyCollectionIdsByCityId, cityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var collection_id string
		if err := rows.Scan(&collection_id); err != nil {
			return nil, err
		}
		items = append(items, collection_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findManyCollectionIdsByPlaceId = `-- name: FindManyCollectionIdsByPlaceId :many
SELECT collection_id FROM collections_places
WHERE place_id = $1
`

func (q *Queries) FindManyCollectionIdsByPlaceId(ctx context.Context, placeID string) ([]string, error) {
	rows, err := q.db.Query(ctx, findManyCollectionIdsByPlaceId, placeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var collection_id string
		if err := rows.Scan(&collection_id); err != nil {
			return nil, err
		}
		items = append(items, collection_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findManyCollectionPlaceRelations = `-- name: FindManyCollectionPlaceRelations :many
SELECT collection_id, place_id, index FROM collections_places
`

func (q *Queries) FindManyCollectionPlaceRelations(ctx context.Context) ([]CollectionsPlace, error) {
	rows, err := q.db.Query(ctx, findManyCollectionPlaceRelations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CollectionsPlace
	for rows.Next() {
		var i CollectionsPlace
		if err := rows.Scan(&i.CollectionID, &i.PlaceID, &i.Index); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findManyCollections = `-- name: FindManyCollections :many
SELECT 
  collections.id, collections.name, collections.description, collections.created_at,
  (SELECT json_agg(DISTINCT jsonb_build_object(
    'collectionId', items.collection_id,
    'placeId', items.place_id,
    'index', items.index,
    'createdAt', items.created_at
  ))
  FROM collection_items items
  WHERE items.collection_id = collections.id
  ) AS items,
  (SELECT get_places(
    ARRAY(
      SELECT 
        DISTINCT place_id
      FROM collection_items 
      WHERE collection_id = collections.id
    )
  )) AS places
FROM collections
WHERE collections.id = ANY($1::TEXT[])
GROUP BY collections.id
`

type FindManyCollectionsRow struct {
	Collection Collection
	Items      []byte
	Places     []byte
}

func (q *Queries) FindManyCollections(ctx context.Context, dollar_1 []string) ([]FindManyCollectionsRow, error) {
	rows, err := q.db.Query(ctx, findManyCollections, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindManyCollectionsRow
	for rows.Next() {
		var i FindManyCollectionsRow
		if err := rows.Scan(
			&i.Collection.ID,
			&i.Collection.Name,
			&i.Collection.Description,
			&i.Collection.CreatedAt,
			&i.Items,
			&i.Places,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCollectionById = `-- name: RemoveCollectionById :execresult
DELETE FROM collections
WHERE id = $1
`

func (q *Queries) RemoveCollectionById(ctx context.Context, id string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, removeCollectionById, id)
}

const removeCollectionCityRelation = `-- name: RemoveCollectionCityRelation :execresult
DELETE FROM collections_cities
WHERE collection_id = $1 AND city_id = $2
`

type RemoveCollectionCityRelationParams struct {
	CollectionID string
	CityID       int32
}

func (q *Queries) RemoveCollectionCityRelation(ctx context.Context, arg RemoveCollectionCityRelationParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, removeCollectionCityRelation, arg.CollectionID, arg.CityID)
}

const removeCollectionItemByCollectionIdAndIndex = `-- name: RemoveCollectionItemByCollectionIdAndIndex :execresult
DELETE FROM collection_items
WHERE collection_id = $1 AND index = $2
`

type RemoveCollectionItemByCollectionIdAndIndexParams struct {
	CollectionID string
	Index        int32
}

func (q *Queries) RemoveCollectionItemByCollectionIdAndIndex(ctx context.Context, arg RemoveCollectionItemByCollectionIdAndIndexParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, removeCollectionItemByCollectionIdAndIndex, arg.CollectionID, arg.Index)
}

const removeCollectionItemsByCollectionId = `-- name: RemoveCollectionItemsByCollectionId :execresult
DELETE FROM collection_items
WHERE collection_id = $1
`

func (q *Queries) RemoveCollectionItemsByCollectionId(ctx context.Context, collectionID string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, removeCollectionItemsByCollectionId, collectionID)
}

const removeCollectionPlaceRelation = `-- name: RemoveCollectionPlaceRelation :execresult
DELETE FROM collections_places
WHERE collection_id = $1 AND place_id = $2
`

type RemoveCollectionPlaceRelationParams struct {
	CollectionID string
	PlaceID      string
}

func (q *Queries) RemoveCollectionPlaceRelation(ctx context.Context, arg RemoveCollectionPlaceRelationParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, removeCollectionPlaceRelation, arg.CollectionID, arg.PlaceID)
}

const updateCollection = `-- name: UpdateCollection :execresult
UPDATE collections
SET
  name = $1,
  description = $2
WHERE id = $3
`

type UpdateCollectionParams struct {
	Name        string
	Description string
	ID          string
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateCollection, arg.Name, arg.Description, arg.ID)
}
