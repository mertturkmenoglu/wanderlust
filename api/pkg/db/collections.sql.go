// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: collections.sql

package db

import (
	"context"
)

const countCollections = `-- name: CountCollections :one
SELECT count(*) FROM collections
`

func (q *Queries) CountCollections(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCollections)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (
  id,
  name,
  description
) VALUES (
  $1,
  $2,
  $3
) RETURNING id, name, description, created_at
`

type CreateCollectionParams struct {
	ID          string
	Name        string
	Description string
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, createCollection, arg.ID, arg.Name, arg.Description)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createCollectionCityRelation = `-- name: CreateCollectionCityRelation :exec
INSERT INTO collections_cities (
  collection_id,
  city_id,
  index
) VALUES (
  $1,
  $2,
  $3
)
`

type CreateCollectionCityRelationParams struct {
	CollectionID string
	CityID       int32
	Index        int32
}

func (q *Queries) CreateCollectionCityRelation(ctx context.Context, arg CreateCollectionCityRelationParams) error {
	_, err := q.db.Exec(ctx, createCollectionCityRelation, arg.CollectionID, arg.CityID, arg.Index)
	return err
}

const createCollectionItem = `-- name: CreateCollectionItem :one
INSERT INTO collection_items (
  collection_id,
  poi_id,
  index
) VALUES (
  $1,
  $2,
  $3
) RETURNING collection_id, poi_id, index, created_at
`

type CreateCollectionItemParams struct {
	CollectionID string
	PoiID        string
	Index        int32
}

func (q *Queries) CreateCollectionItem(ctx context.Context, arg CreateCollectionItemParams) (CollectionItem, error) {
	row := q.db.QueryRow(ctx, createCollectionItem, arg.CollectionID, arg.PoiID, arg.Index)
	var i CollectionItem
	err := row.Scan(
		&i.CollectionID,
		&i.PoiID,
		&i.Index,
		&i.CreatedAt,
	)
	return i, err
}

const createCollectionPoiRelation = `-- name: CreateCollectionPoiRelation :exec
INSERT INTO collections_pois (
  collection_id,
  poi_id,
  index
) VALUES (
  $1,
  $2,
  $3
)
`

type CreateCollectionPoiRelationParams struct {
	CollectionID string
	PoiID        string
	Index        int32
}

func (q *Queries) CreateCollectionPoiRelation(ctx context.Context, arg CreateCollectionPoiRelationParams) error {
	_, err := q.db.Exec(ctx, createCollectionPoiRelation, arg.CollectionID, arg.PoiID, arg.Index)
	return err
}

const decrListIndexAfterDelete = `-- name: DecrListIndexAfterDelete :exec
UPDATE collection_items
SET 
  list_index = list_index - 1
WHERE collection_id = $1 AND index > $2
`

type DecrListIndexAfterDeleteParams struct {
	CollectionID string
	Index        int32
}

func (q *Queries) DecrListIndexAfterDelete(ctx context.Context, arg DecrListIndexAfterDeleteParams) error {
	_, err := q.db.Exec(ctx, decrListIndexAfterDelete, arg.CollectionID, arg.Index)
	return err
}

const deleteAllCollectionItems = `-- name: DeleteAllCollectionItems :exec
DELETE FROM collection_items
WHERE collection_id = $1
`

func (q *Queries) DeleteAllCollectionItems(ctx context.Context, collectionID string) error {
	_, err := q.db.Exec(ctx, deleteAllCollectionItems, collectionID)
	return err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections
WHERE id = $1
`

func (q *Queries) DeleteCollection(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteCollection, id)
	return err
}

const deleteCollectionItemAtIndex = `-- name: DeleteCollectionItemAtIndex :exec
DELETE FROM collection_items
WHERE collection_id = $1 AND index = $2
`

type DeleteCollectionItemAtIndexParams struct {
	CollectionID string
	Index        int32
}

func (q *Queries) DeleteCollectionItemAtIndex(ctx context.Context, arg DeleteCollectionItemAtIndexParams) error {
	_, err := q.db.Exec(ctx, deleteCollectionItemAtIndex, arg.CollectionID, arg.Index)
	return err
}

const getAllCityCollections = `-- name: GetAllCityCollections :many
SELECT collection_id, city_id, index FROM collections_cities
`

func (q *Queries) GetAllCityCollections(ctx context.Context) ([]CollectionsCity, error) {
	rows, err := q.db.Query(ctx, getAllCityCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CollectionsCity
	for rows.Next() {
		var i CollectionsCity
		if err := rows.Scan(&i.CollectionID, &i.CityID, &i.Index); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPoiCollections = `-- name: GetAllPoiCollections :many
SELECT collection_id, poi_id, index FROM collections_pois
`

func (q *Queries) GetAllPoiCollections(ctx context.Context) ([]CollectionsPoi, error) {
	rows, err := q.db.Query(ctx, getAllPoiCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CollectionsPoi
	for rows.Next() {
		var i CollectionsPoi
		if err := rows.Scan(&i.CollectionID, &i.PoiID, &i.Index); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionIds = `-- name: GetCollectionIds :many
SELECT id FROM collections
OFFSET $1
LIMIT $2
`

type GetCollectionIdsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetCollectionIds(ctx context.Context, arg GetCollectionIdsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getCollectionIds, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionIdsForPoi = `-- name: GetCollectionIdsForPoi :many
SELECT collection_id FROM collections_pois
WHERE poi_id = $1
`

func (q *Queries) GetCollectionIdsForPoi(ctx context.Context, poiID string) ([]string, error) {
	rows, err := q.db.Query(ctx, getCollectionIdsForPoi, poiID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var collection_id string
		if err := rows.Scan(&collection_id); err != nil {
			return nil, err
		}
		items = append(items, collection_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionItem = `-- name: GetCollectionItem :one
SELECT collection_id, poi_id, index, created_at FROM collection_items
WHERE collection_id = $1 AND poi_id = $2
LIMIT 1
`

type GetCollectionItemParams struct {
	CollectionID string
	PoiID        string
}

func (q *Queries) GetCollectionItem(ctx context.Context, arg GetCollectionItemParams) (CollectionItem, error) {
	row := q.db.QueryRow(ctx, getCollectionItem, arg.CollectionID, arg.PoiID)
	var i CollectionItem
	err := row.Scan(
		&i.CollectionID,
		&i.PoiID,
		&i.Index,
		&i.CreatedAt,
	)
	return i, err
}

const getCollections = `-- name: GetCollections :many
SELECT 
  collections.id, collections.name, collections.description, collections.created_at,
  (SELECT json_agg(DISTINCT jsonb_build_object(
    'collectionId', items.collection_id,
    'poiId', items.poi_id,
    'index', items.index,
    'createdAt', items.created_at
  ))
  FROM collection_items items
  WHERE items.collection_id = collections.id
  ) AS items,
  (SELECT get_pois(
    ARRAY(
      SELECT 
        DISTINCT poi_id 
      FROM collection_items 
      WHERE collection_id = collections.id
    )
  )) AS pois
FROM collections
WHERE collections.id = ANY($1::TEXT[])
GROUP BY collections.id
`

type GetCollectionsRow struct {
	Collection Collection
	Items      []byte
	Pois       []byte
}

func (q *Queries) GetCollections(ctx context.Context, dollar_1 []string) ([]GetCollectionsRow, error) {
	rows, err := q.db.Query(ctx, getCollections, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionsRow
	for rows.Next() {
		var i GetCollectionsRow
		if err := rows.Scan(
			&i.Collection.ID,
			&i.Collection.Name,
			&i.Collection.Description,
			&i.Collection.CreatedAt,
			&i.Items,
			&i.Pois,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionsIdsForCity = `-- name: GetCollectionsIdsForCity :many
SELECT collection_id FROM collections_cities
WHERE city_id = $1
`

func (q *Queries) GetCollectionsIdsForCity(ctx context.Context, cityID int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getCollectionsIdsForCity, cityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var collection_id string
		if err := rows.Scan(&collection_id); err != nil {
			return nil, err
		}
		items = append(items, collection_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastIndexOfCollection = `-- name: GetLastIndexOfCollection :one
SELECT COALESCE(MAX(list_index), 0)
FROM collection_items
WHERE collection_id = $1
`

func (q *Queries) GetLastIndexOfCollection(ctx context.Context, collectionID string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getLastIndexOfCollection, collectionID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const removeCollectionCityRelation = `-- name: RemoveCollectionCityRelation :exec
DELETE FROM collections_cities
WHERE collection_id = $1 AND city_id = $2
`

type RemoveCollectionCityRelationParams struct {
	CollectionID string
	CityID       int32
}

func (q *Queries) RemoveCollectionCityRelation(ctx context.Context, arg RemoveCollectionCityRelationParams) error {
	_, err := q.db.Exec(ctx, removeCollectionCityRelation, arg.CollectionID, arg.CityID)
	return err
}

const removeCollectionPoiRelation = `-- name: RemoveCollectionPoiRelation :exec
DELETE FROM collections_pois
WHERE collection_id = $1 AND poi_id = $2
`

type RemoveCollectionPoiRelationParams struct {
	CollectionID string
	PoiID        string
}

func (q *Queries) RemoveCollectionPoiRelation(ctx context.Context, arg RemoveCollectionPoiRelationParams) error {
	_, err := q.db.Exec(ctx, removeCollectionPoiRelation, arg.CollectionID, arg.PoiID)
	return err
}

const updateCollection = `-- name: UpdateCollection :exec
UPDATE collections
SET 
  name = $1,
  description = $2
WHERE id = $3
`

type UpdateCollectionParams struct {
	Name        string
	Description string
	ID          string
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) error {
	_, err := q.db.Exec(ctx, updateCollection, arg.Name, arg.Description, arg.ID)
	return err
}
