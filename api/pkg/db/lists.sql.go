// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: lists.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
)

type BatchCreateListItemsParams struct {
	ListID  string
	PlaceID string
	Index   int32
}

type BatchCreateListsParams struct {
	ID       string
	Name     string
	UserID   string
	IsPublic bool
}

const countListItemsByListId = `-- name: CountListItemsByListId :one
SELECT COUNT(*)
FROM list_items
WHERE list_id = $1
`

func (q *Queries) CountListItemsByListId(ctx context.Context, listID string) (int64, error) {
	row := q.db.QueryRow(ctx, countListItemsByListId, listID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countListsByUserId = `-- name: CountListsByUserId :one
SELECT COUNT(*)
FROM lists
WHERE user_id = $1
`

func (q *Queries) CountListsByUserId(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countListsByUserId, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countListsByUserIdAndIsPublic = `-- name: CountListsByUserIdAndIsPublic :one
SELECT COUNT(*)
FROM lists
WHERE user_id = $1 AND is_public = true
`

func (q *Queries) CountListsByUserIdAndIsPublic(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countListsByUserIdAndIsPublic, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createList = `-- name: CreateList :one
INSERT INTO lists (
  id,
  name,
  user_id,
  is_public
) VALUES (
  $1,
  $2,
  $3,
  $4
) RETURNING id, name, user_id, is_public, created_at, updated_at
`

type CreateListParams struct {
	ID       string
	Name     string
	UserID   string
	IsPublic bool
}

func (q *Queries) CreateList(ctx context.Context, arg CreateListParams) (List, error) {
	row := q.db.QueryRow(ctx, createList,
		arg.ID,
		arg.Name,
		arg.UserID,
		arg.IsPublic,
	)
	var i List
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createListItem = `-- name: CreateListItem :one
INSERT INTO list_items (
  list_id,
  place_id,
  index
) VALUES (
  $1,
  $2,
  $3
) RETURNING list_id, place_id, index, created_at
`

type CreateListItemParams struct {
	ListID  string
	PlaceID string
	Index   int32
}

func (q *Queries) CreateListItem(ctx context.Context, arg CreateListItemParams) (ListItem, error) {
	row := q.db.QueryRow(ctx, createListItem, arg.ListID, arg.PlaceID, arg.Index)
	var i ListItem
	err := row.Scan(
		&i.ListID,
		&i.PlaceID,
		&i.Index,
		&i.CreatedAt,
	)
	return i, err
}

const findListById = `-- name: FindListById :one
SELECT
  lists.id, lists.name, lists.user_id, lists.is_public, lists.created_at, lists.updated_at,
  profile.id, profile.username, profile.full_name, profile.is_verified, profile.bio, profile.profile_image, profile.banner_image, profile.followers_count, profile.following_count, profile.created_at
FROM lists
  LEFT JOIN profile ON profile.id = lists.user_id
WHERE lists.id = $1
LIMIT 1
`

type FindListByIdRow struct {
	List    List
	Profile Profile
}

func (q *Queries) FindListById(ctx context.Context, id string) (FindListByIdRow, error) {
	row := q.db.QueryRow(ctx, findListById, id)
	var i FindListByIdRow
	err := row.Scan(
		&i.List.ID,
		&i.List.Name,
		&i.List.UserID,
		&i.List.IsPublic,
		&i.List.CreatedAt,
		&i.List.UpdatedAt,
		&i.Profile.ID,
		&i.Profile.Username,
		&i.Profile.FullName,
		&i.Profile.IsVerified,
		&i.Profile.Bio,
		&i.Profile.ProfileImage,
		&i.Profile.BannerImage,
		&i.Profile.FollowersCount,
		&i.Profile.FollowingCount,
		&i.Profile.CreatedAt,
	)
	return i, err
}

const findListIdAndNameByUserId = `-- name: FindListIdAndNameByUserId :many
SELECT id, name
FROM lists
WHERE user_id = $1
`

type FindListIdAndNameByUserIdRow struct {
	ID   string
	Name string
}

func (q *Queries) FindListIdAndNameByUserId(ctx context.Context, userID string) ([]FindListIdAndNameByUserIdRow, error) {
	rows, err := q.db.Query(ctx, findListIdAndNameByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindListIdAndNameByUserIdRow
	for rows.Next() {
		var i FindListIdAndNameByUserIdRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findListItemByListIdAndPlaceId = `-- name: FindListItemByListIdAndPlaceId :one
SELECT list_id, place_id, index, created_at
FROM list_items
WHERE list_id = $1 AND place_id = $2
LIMIT 1
`

type FindListItemByListIdAndPlaceIdParams struct {
	ListID  string
	PlaceID string
}

func (q *Queries) FindListItemByListIdAndPlaceId(ctx context.Context, arg FindListItemByListIdAndPlaceIdParams) (ListItem, error) {
	row := q.db.QueryRow(ctx, findListItemByListIdAndPlaceId, arg.ListID, arg.PlaceID)
	var i ListItem
	err := row.Scan(
		&i.ListID,
		&i.PlaceID,
		&i.Index,
		&i.CreatedAt,
	)
	return i, err
}

const findListLastIndexById = `-- name: FindListLastIndexById :one
SELECT COALESCE(MAX(index), 0)
FROM list_items
WHERE list_id = $1
`

func (q *Queries) FindListLastIndexById(ctx context.Context, listID string) (interface{}, error) {
	row := q.db.QueryRow(ctx, findListLastIndexById, listID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const findManyListItems = `-- name: FindManyListItems :many
SELECT
  list_items.list_id, list_items.place_id, list_items.index, list_items.created_at,
  get_places(
    ARRAY(
      SELECT place_id
      FROM list_items
      WHERE list_items.list_id = $1
    )
  ) as places
FROM list_items
WHERE list_id = $1
ORDER BY index ASC
`

type FindManyListItemsRow struct {
	ListItem ListItem
	Places   []byte
}

func (q *Queries) FindManyListItems(ctx context.Context, listID string) ([]FindManyListItemsRow, error) {
	rows, err := q.db.Query(ctx, findManyListItems, listID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindManyListItemsRow
	for rows.Next() {
		var i FindManyListItemsRow
		if err := rows.Scan(
			&i.ListItem.ListID,
			&i.ListItem.PlaceID,
			&i.ListItem.Index,
			&i.ListItem.CreatedAt,
			&i.Places,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findManyListsByUserId = `-- name: FindManyListsByUserId :many
SELECT id, name, user_id, is_public, created_at, updated_at
FROM lists
WHERE user_id = $1
ORDER BY created_at DESC
OFFSET $2
LIMIT $3
`

type FindManyListsByUserIdParams struct {
	UserID string
	Offset int32
	Limit  int32
}

func (q *Queries) FindManyListsByUserId(ctx context.Context, arg FindManyListsByUserIdParams) ([]List, error) {
	rows, err := q.db.Query(ctx, findManyListsByUserId, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []List
	for rows.Next() {
		var i List
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findManyListsByUserIdAndIsPublic = `-- name: FindManyListsByUserIdAndIsPublic :many
SELECT id, name, user_id, is_public, created_at, updated_at
FROM lists
WHERE user_id = $1 AND is_public = true
ORDER BY created_at DESC
OFFSET $2
LIMIT $3
`

type FindManyListsByUserIdAndIsPublicParams struct {
	UserID string
	Offset int32
	Limit  int32
}

func (q *Queries) FindManyListsByUserIdAndIsPublic(ctx context.Context, arg FindManyListsByUserIdAndIsPublicParams) ([]List, error) {
	rows, err := q.db.Query(ctx, findManyListsByUserIdAndIsPublic, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []List
	for rows.Next() {
		var i List
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPlaceInListStatus = `-- name: FindPlaceInListStatus :many
SELECT list_id, place_id
FROM list_items
WHERE list_items.place_id = $1 AND list_items.list_id = ANY($2::TEXT[])
`

type FindPlaceInListStatusParams struct {
	PlaceID string
	Column2 []string
}

type FindPlaceInListStatusRow struct {
	ListID  string
	PlaceID string
}

func (q *Queries) FindPlaceInListStatus(ctx context.Context, arg FindPlaceInListStatusParams) ([]FindPlaceInListStatusRow, error) {
	rows, err := q.db.Query(ctx, findPlaceInListStatus, arg.PlaceID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindPlaceInListStatusRow
	for rows.Next() {
		var i FindPlaceInListStatusRow
		if err := rows.Scan(&i.ListID, &i.PlaceID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeList = `-- name: RemoveList :execresult
DELETE FROM lists
WHERE id = $1
`

func (q *Queries) RemoveList(ctx context.Context, id string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, removeList, id)
}

const removeListItemsByListId = `-- name: RemoveListItemsByListId :execresult
DELETE FROM list_items
WHERE list_id = $1
`

func (q *Queries) RemoveListItemsByListId(ctx context.Context, listID string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, removeListItemsByListId, listID)
}

const updateList = `-- name: UpdateList :execresult
UPDATE lists
SET
  name = $2,
  is_public = $3
WHERE id = $1
`

type UpdateListParams struct {
	ID       string
	Name     string
	IsPublic bool
}

func (q *Queries) UpdateList(ctx context.Context, arg UpdateListParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateList, arg.ID, arg.Name, arg.IsPublic)
}
