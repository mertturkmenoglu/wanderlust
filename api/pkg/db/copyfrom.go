// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: copyfrom.go

package db

import (
	"context"
)

// iteratorForBatchCreateAddresses implements pgx.CopyFromSource.
type iteratorForBatchCreateAddresses struct {
	rows                 []BatchCreateAddressesParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreateAddresses) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreateAddresses) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].CityID,
		r.rows[0].Line1,
		r.rows[0].Line2,
		r.rows[0].PostalCode,
		r.rows[0].Lat,
		r.rows[0].Lng,
	}, nil
}

func (r iteratorForBatchCreateAddresses) Err() error {
	return nil
}

func (q *Queries) BatchCreateAddresses(ctx context.Context, arg []BatchCreateAddressesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"addresses"}, []string{"city_id", "line1", "line2", "postal_code", "lat", "lng"}, &iteratorForBatchCreateAddresses{rows: arg})
}

// iteratorForBatchCreateAmenitiesPois implements pgx.CopyFromSource.
type iteratorForBatchCreateAmenitiesPois struct {
	rows                 []BatchCreateAmenitiesPoisParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreateAmenitiesPois) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreateAmenitiesPois) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].AmenityID,
		r.rows[0].PoiID,
	}, nil
}

func (r iteratorForBatchCreateAmenitiesPois) Err() error {
	return nil
}

func (q *Queries) BatchCreateAmenitiesPois(ctx context.Context, arg []BatchCreateAmenitiesPoisParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"amenities_pois"}, []string{"amenity_id", "poi_id"}, &iteratorForBatchCreateAmenitiesPois{rows: arg})
}

// iteratorForBatchCreateDiaryLocations implements pgx.CopyFromSource.
type iteratorForBatchCreateDiaryLocations struct {
	rows                 []BatchCreateDiaryLocationsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreateDiaryLocations) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreateDiaryLocations) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].DiaryID,
		r.rows[0].PoiID,
		r.rows[0].Description,
		r.rows[0].Index,
	}, nil
}

func (r iteratorForBatchCreateDiaryLocations) Err() error {
	return nil
}

func (q *Queries) BatchCreateDiaryLocations(ctx context.Context, arg []BatchCreateDiaryLocationsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"diary_pois"}, []string{"diary_id", "poi_id", "description", "index"}, &iteratorForBatchCreateDiaryLocations{rows: arg})
}

// iteratorForBatchCreateDiaryUsers implements pgx.CopyFromSource.
type iteratorForBatchCreateDiaryUsers struct {
	rows                 []BatchCreateDiaryUsersParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreateDiaryUsers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreateDiaryUsers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].DiaryID,
		r.rows[0].UserID,
		r.rows[0].Index,
	}, nil
}

func (r iteratorForBatchCreateDiaryUsers) Err() error {
	return nil
}

func (q *Queries) BatchCreateDiaryUsers(ctx context.Context, arg []BatchCreateDiaryUsersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"diary_users"}, []string{"diary_id", "user_id", "index"}, &iteratorForBatchCreateDiaryUsers{rows: arg})
}

// iteratorForBatchCreatePois implements pgx.CopyFromSource.
type iteratorForBatchCreatePois struct {
	rows                 []BatchCreatePoisParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreatePois) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreatePois) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Name,
		r.rows[0].Phone,
		r.rows[0].Description,
		r.rows[0].AddressID,
		r.rows[0].Website,
		r.rows[0].PriceLevel,
		r.rows[0].AccessibilityLevel,
		r.rows[0].TotalVotes,
		r.rows[0].TotalPoints,
		r.rows[0].TotalFavorites,
		r.rows[0].CategoryID,
		r.rows[0].Hours,
	}, nil
}

func (r iteratorForBatchCreatePois) Err() error {
	return nil
}

func (q *Queries) BatchCreatePois(ctx context.Context, arg []BatchCreatePoisParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"pois"}, []string{"id", "name", "phone", "description", "address_id", "website", "price_level", "accessibility_level", "total_votes", "total_points", "total_favorites", "category_id", "hours"}, &iteratorForBatchCreatePois{rows: arg})
}

// iteratorForBatchCreateReports implements pgx.CopyFromSource.
type iteratorForBatchCreateReports struct {
	rows                 []BatchCreateReportsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreateReports) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreateReports) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].ResourceID,
		r.rows[0].ResourceType,
		r.rows[0].ReporterID,
		r.rows[0].Description,
		r.rows[0].Reason,
	}, nil
}

func (r iteratorForBatchCreateReports) Err() error {
	return nil
}

func (q *Queries) BatchCreateReports(ctx context.Context, arg []BatchCreateReportsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"reports"}, []string{"id", "resource_id", "resource_type", "reporter_id", "description", "reason"}, &iteratorForBatchCreateReports{rows: arg})
}

// iteratorForBatchCreateReviewImage implements pgx.CopyFromSource.
type iteratorForBatchCreateReviewImage struct {
	rows                 []BatchCreateReviewImageParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreateReviewImage) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreateReviewImage) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ReviewID,
		r.rows[0].Url,
		r.rows[0].Index,
	}, nil
}

func (r iteratorForBatchCreateReviewImage) Err() error {
	return nil
}

func (q *Queries) BatchCreateReviewImage(ctx context.Context, arg []BatchCreateReviewImageParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"review_images"}, []string{"review_id", "url", "index"}, &iteratorForBatchCreateReviewImage{rows: arg})
}

// iteratorForBatchCreateReviews implements pgx.CopyFromSource.
type iteratorForBatchCreateReviews struct {
	rows                 []BatchCreateReviewsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreateReviews) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreateReviews) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].PoiID,
		r.rows[0].UserID,
		r.rows[0].Content,
		r.rows[0].Rating,
	}, nil
}

func (r iteratorForBatchCreateReviews) Err() error {
	return nil
}

func (q *Queries) BatchCreateReviews(ctx context.Context, arg []BatchCreateReviewsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"reviews"}, []string{"id", "poi_id", "user_id", "content", "rating"}, &iteratorForBatchCreateReviews{rows: arg})
}

// iteratorForBatchCreateTripAmenities implements pgx.CopyFromSource.
type iteratorForBatchCreateTripAmenities struct {
	rows                 []BatchCreateTripAmenitiesParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreateTripAmenities) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreateTripAmenities) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].TripID,
		r.rows[0].AmenityID,
	}, nil
}

func (r iteratorForBatchCreateTripAmenities) Err() error {
	return nil
}

func (q *Queries) BatchCreateTripAmenities(ctx context.Context, arg []BatchCreateTripAmenitiesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"trip_amenities"}, []string{"trip_id", "amenity_id"}, &iteratorForBatchCreateTripAmenities{rows: arg})
}

// iteratorForBatchCreateTrips implements pgx.CopyFromSource.
type iteratorForBatchCreateTrips struct {
	rows                 []BatchCreateTripsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreateTrips) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreateTrips) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].OwnerID,
		r.rows[0].Description,
		r.rows[0].Title,
		r.rows[0].VisibilityLevel,
		r.rows[0].StartAt,
		r.rows[0].EndAt,
	}, nil
}

func (r iteratorForBatchCreateTrips) Err() error {
	return nil
}

func (q *Queries) BatchCreateTrips(ctx context.Context, arg []BatchCreateTripsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"trips"}, []string{"id", "owner_id", "description", "title", "visibility_level", "start_at", "end_at"}, &iteratorForBatchCreateTrips{rows: arg})
}

// iteratorForBatchCreateUsers implements pgx.CopyFromSource.
type iteratorForBatchCreateUsers struct {
	rows                 []BatchCreateUsersParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchCreateUsers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchCreateUsers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Email,
		r.rows[0].Username,
		r.rows[0].FullName,
		r.rows[0].PasswordHash,
		r.rows[0].GoogleID,
		r.rows[0].FbID,
		r.rows[0].ProfileImage,
	}, nil
}

func (r iteratorForBatchCreateUsers) Err() error {
	return nil
}

func (q *Queries) BatchCreateUsers(ctx context.Context, arg []BatchCreateUsersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"users"}, []string{"id", "email", "username", "full_name", "password_hash", "google_id", "fb_id", "profile_image"}, &iteratorForBatchCreateUsers{rows: arg})
}

// iteratorForBatchFollow implements pgx.CopyFromSource.
type iteratorForBatchFollow struct {
	rows                 []BatchFollowParams
	skippedFirstNextCall bool
}

func (r *iteratorForBatchFollow) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBatchFollow) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].FollowerID,
		r.rows[0].FollowingID,
	}, nil
}

func (r iteratorForBatchFollow) Err() error {
	return nil
}

func (q *Queries) BatchFollow(ctx context.Context, arg []BatchFollowParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"follows"}, []string{"follower_id", "following_id"}, &iteratorForBatchFollow{rows: arg})
}

// iteratorForCreateCities implements pgx.CopyFromSource.
type iteratorForCreateCities struct {
	rows                 []CreateCitiesParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateCities) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateCities) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Name,
		r.rows[0].StateCode,
		r.rows[0].StateName,
		r.rows[0].CountryCode,
		r.rows[0].CountryName,
		r.rows[0].Image,
		r.rows[0].Latitude,
		r.rows[0].Longitude,
		r.rows[0].Description,
	}, nil
}

func (r iteratorForCreateCities) Err() error {
	return nil
}

func (q *Queries) CreateCities(ctx context.Context, arg []CreateCitiesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"cities"}, []string{"id", "name", "state_code", "state_name", "country_code", "country_name", "image", "latitude", "longitude", "description"}, &iteratorForCreateCities{rows: arg})
}
